import torch

class Model(torch.nn.Module):
    def __init__(self, num_classes): 
        super(Model, self).__init__()
        # 用torch.nn.Sequential方法将网络打包成一个模块，精简代码，不需要每一步都写成self.conv1 = ...的格式了
        self.features = torch.nn.Sequential( # 定义卷积层提取图像特征
            # 计算output的size的计算公式：(input_size-kernel_size+padding)/stride + 1
            torch.nn.Conv2d(3, 48, kernel_size=11, padding=2, stride=4), # input(3, 244, 244) output(48, 55, 55)
            torch.nn.ReLU(inplace=True), # 直接修改覆盖原值，节省运算内存
            torch.nn.MaxPool2d(kernel_size=3, padding=0, stride=2), # input(48, 55, 55) output(48, 27, 27)
            torch.nn.Conv2d(48, 128, kernel_size=5, padding=2, stride=1), # input(48, 27, 27) output(128, 27, 27)
            torch.nn.ReLU(inplace=True),
            torch.nn.MaxPool2d(kernel_size=3, padding=0, stride=2), # input(128, 27, 27) output(128, 13, 13)
            torch.nn.Conv2d(128, 192, kernel_size=3, padding=1, stride=1), # input(128, 13, 13) output(192, 13, 13)
            torch.nn.ReLU(inplace=True),
            torch.nn.Conv2d(192, 192, kernel_size=3, padding=1, stride=1),  # input(192, 13, 13) output(192, 13, 13)
            torch.nn.ReLU(inplace=True),
            torch.nn.Conv2d(192, 128, kernel_size=3, padding=1, stride=1),  # input(192, 13, 13) output(128, 13, 13)
            torch.nn.ReLU(inplace=True),
            torch.nn.MaxPool2d(kernel_size=3, padding=0, stride=2), # input(128, 13, 13) output(128, 6, 6)
        )

        self.classifier = torch.nn.Sequential( # 定义全连接层图像分类
            # dropout随机失活神经元，默认比例0.5，一般加在全连接层防止过拟合 提升模型泛化能力。卷积层一般很少加，因为卷积参数少，不易过拟合
            torch.nn.Dropout(0.5),
            torch.nn.Linear(128*6*6, 2048) ,
            torch.nn.ReLU(inplace=True),
            torch.nn.Dropout(0.5),
            torch.nn.Linear(2048, 2048),
            torch.nn.ReLU(inplace=True),
            torch.nn.Dropout(0.5),
            torch.nn.Linear(2048, num_classes),
        )

    def forward(self, x):
       x = self.features(x)
       x = torch.flatten(x, start_dim=1) # (batch_size, c , H, W)即从通道c开始对x进行展平
       x = self.classifier(x)
       return x
